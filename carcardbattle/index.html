<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÂÆüÂÜôÈ¢®„Ç´„Éº„Ç´„Éº„Éâ„Éê„Éà„É´</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        canvas {
            display: block;
            max-width: 100%;
            max-height: 100vh;
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        // ============================================
        // „Éá„Éº„ÇøÂÆöÁæ©
        // ============================================
        // Â±ûÊÄß„Ç∑„Çπ„ÉÜ„É†ÂÆöÁæ©
        const ELEMENTS = {
            fire: { name: "ÁÅ´", icon: "üî•", color: "#ff4422", bgColor: "rgba(255, 68, 34, 0.3)" },
            earth: { name: "Âúü", icon: "üåç", color: "#8b4513", bgColor: "rgba(139, 69, 19, 0.3)" },
            wind: { name: "È¢®", icon: "üå™Ô∏è", color: "#00cc88", bgColor: "rgba(0, 204, 136, 0.3)" },
            thunder: { name: "Èõ∑", icon: "‚ö°", color: "#ffdd00", bgColor: "rgba(255, 221, 0, 0.3)" }
        };

        // Â±ûÊÄßÁõ∏ÊÄß: ÁÅ´ÔºûÈ¢®ÔºûÈõ∑ÔºûÂúüÔºûÁÅ´
        const ELEMENT_ADVANTAGE = {
            fire: "wind",     // ÁÅ´„ÅØÈ¢®„Å´Âº∑„ÅÑ
            wind: "thunder",  // È¢®„ÅØÈõ∑„Å´Âº∑„ÅÑ
            thunder: "earth", // Èõ∑„ÅØÂúü„Å´Âº∑„ÅÑ
            earth: "fire"     // Âúü„ÅØÁÅ´„Å´Âº∑„ÅÑ
        };

        const CAR_DATA = [
            // „ÄêN: Normal„Äë (AP 10-22)
            { name: "Honda N-BOX", en: "Honda N-BOX keicar white", rarity: "N", ap: 10, element: "wind" },
            { name: "Daihatsu Tanto", en: "Daihatsu Tanto keicar", rarity: "N", ap: 12, element: "earth" },
            { name: "Suzuki Spacia", en: "Suzuki Spacia gear green", rarity: "N", ap: 12, element: "wind" },
            { name: "Suzuki Jimny", en: "Suzuki Jimny offroad jungle", rarity: "N", ap: 15, element: "earth" },
            { name: "Daihatsu Move Canbus", en: "Daihatsu Move Canbus cute two-tone", rarity: "N", ap: 11, element: "wind" },
            { name: "Suzuki Hustler", en: "Suzuki Hustler orange car", rarity: "N", ap: 13, element: "fire" },
            { name: "Nissan Sakura", en: "Nissan Sakura EV pink gold", rarity: "N", ap: 14, element: "thunder" },
            { name: "Toyota Yaris", en: "Toyota Yaris hatchback red", rarity: "N", ap: 20, element: "fire" },
            { name: "Toyota Aqua", en: "Toyota Aqua Prius C blue", rarity: "N", ap: 18, element: "thunder" },
            { name: "Honda Fit", en: "Honda Fit Jazz white", rarity: "N", ap: 19, element: "wind" },
            { name: "Nissan Note", en: "Nissan Note Aura silver", rarity: "N", ap: 22, element: "thunder" },
            { name: "Mazda 2", en: "Mazda 2 demio red metallic", rarity: "N", ap: 18, element: "fire" },

            // „ÄêR: Rare„Äë (AP 32-42)
            { name: "Toyota Voxy", en: "Toyota Voxy minivan black sharp front", rarity: "R", ap: 35, element: "earth" },
            { name: "Honda Step WGN", en: "Honda Step WGN boxy white", rarity: "R", ap: 34, element: "wind" },
            { name: "Nissan Serena", en: "Nissan Serena highway star silver", rarity: "R", ap: 33, element: "thunder" },
            { name: "Mitsubishi Delica D:5", en: "Mitsubishi Delica D5 offroad gray", rarity: "R", ap: 38, element: "earth" },
            { name: "Toyota Harrier", en: "Toyota Harrier luxury SUV black", rarity: "R", ap: 40, element: "fire" },
            { name: "Toyota RAV4", en: "Toyota RAV4 adventure offroad mud", rarity: "R", ap: 42, element: "earth" },
            { name: "Mazda CX-5", en: "Mazda CX-5 soul red crystal", rarity: "R", ap: 39, element: "fire" },
            { name: "Subaru Forester", en: "Subaru Forester wilderness forest", rarity: "R", ap: 41, element: "wind" },
            { name: "Honda Vezel", en: "Honda HR-V Vezel white", rarity: "R", ap: 32, element: "wind" },
            { name: "Suzuki Swift Sport", en: "Suzuki Swift Sport yellow circuit", rarity: "R", ap: 36, element: "thunder" },

            // „ÄêSR: Super Rare„Äë (AP 50-70)
            { name: "Toyota Alphard", en: "Toyota Alphard luxury van executive lounge black", rarity: "SR", ap: 55, element: "earth" },
            { name: "Toyota Land Cruiser 300", en: "Toyota Land Cruiser 300 desert", rarity: "SR", ap: 65, element: "earth" },
            { name: "Toyota Crown Crossover", en: "Toyota Crown Crossover bronze", rarity: "SR", ap: 50, element: "thunder" },
            { name: "Lexus RX", en: "Lexus RX 500h f sport white", rarity: "SR", ap: 60, element: "wind" },
            { name: "Nissan Fairlady Z", en: "Nissan Z Proto yellow sports car", rarity: "SR", ap: 68, element: "thunder" },
            { name: "Honda Civic Type R", en: "Honda Civic Type R FL5 white racing", rarity: "SR", ap: 70, element: "fire" },

            // „ÄêSEC: Secret„Äë (AP 95-99)
            { name: "Nissan GT-R NISMO", en: "Nissan GT-R Nismo circuit run smoke", rarity: "SEC", ap: 95, element: "thunder" },
            { name: "Ferrari 296 GTB", en: "Ferrari 296 GTB red italian supercar", rarity: "SEC", ap: 99, element: "fire" }
        ];

        const RARITY_ORDER = ["N", "R", "SR", "SEC"];
        const RARITY_COLORS = {
            N: { primary: "#3498db", secondary: "#2980b9", glow: "#5dade2" },
            R: { primary: "#bdc3c7", secondary: "#95a5a6", glow: "#ecf0f1" },
            SR: { primary: "#9b59b6", secondary: "#8e44ad", glow: "#bb8fce", rainbow: true },
            SEC: { primary: "#f1c40f", secondary: "#f39c12", glow: "#f7dc6f", gold: true },
            GOD: { primary: "#f1c40f", secondary: "#f39c12", glow: "#f7dc6f", gold: true }
        };

        // ============================================
        // ImageLoader „ÇØ„É©„Çπ
        // ============================================
        class ImageLoader {
            constructor() {
                this.cache = new Map();
                this.loading = new Set();
            }

            getImageUrl(carEn, isAnother = false) {
                let prompt = `photorealistic automotive photography of ${carEn}, 8k resolution, cinematic lighting, detailed reflections`;
                if (isAnother) {
                    prompt += ", customized, black body, wide body kit, purple neon glow, dark atmosphere";
                }
                return `https://image.pollinations.ai/prompt/${encodeURIComponent(prompt)}?width=500&height=350&nologo=true`;
            }

            loadImage(carEn, isAnother = false) {
                const key = `${carEn}_${isAnother}`;

                if (this.cache.has(key)) {
                    return Promise.resolve(this.cache.get(key));
                }

                if (this.loading.has(key)) {
                    return new Promise((resolve) => {
                        const check = () => {
                            if (this.cache.has(key)) {
                                resolve(this.cache.get(key));
                            } else {
                                setTimeout(check, 100);
                            }
                        };
                        check();
                    });
                }

                this.loading.add(key);

                return new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = "anonymous";
                    img.onload = () => {
                        this.cache.set(key, img);
                        this.loading.delete(key);
                        resolve(img);
                    };
                    img.onerror = () => {
                        this.loading.delete(key);
                        resolve(null);
                    };
                    img.src = this.getImageUrl(carEn, isAnother);
                });
            }
        }

        // ============================================
        // CardRenderer „ÇØ„É©„Çπ
        // ============================================
        class CardRenderer {
            constructor(ctx, imageLoader) {
                this.ctx = ctx;
                this.imageLoader = imageLoader;
                this.time = 0;
                this.particles = [];
            }

            update(deltaTime) {
                this.time += deltaTime;
                this.particles = this.particles.filter(p => p.life > 0);
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.1;
                    p.life -= deltaTime;
                    p.alpha = Math.max(0, p.life / p.maxLife);
                });
            }

            addParticles(x, y, color, count = 20) {
                for (let i = 0; i < count; i++) {
                    this.particles.push({
                        x, y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10 - 5,
                        size: Math.random() * 6 + 2,
                        color,
                        life: 1,
                        maxLife: 1
                    });
                }
            }

            drawParticles() {
                const ctx = this.ctx;
                this.particles.forEach(p => {
                    ctx.save();
                    ctx.globalAlpha = p.alpha;
                    ctx.fillStyle = p.color;
                    ctx.shadowColor = p.color;
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
            }

            drawCard(x, y, width, height, carData, image, isAnother = false, animProgress = 1) {
                const ctx = this.ctx;
                const rarity = carData.rarity;
                const colors = RARITY_COLORS[rarity] || RARITY_COLORS.N;
                const element = ELEMENTS[carData.element];

                ctx.save();
                ctx.globalAlpha = animProgress;

                // „Ç´„Éº„ÉâËÉåÊôØ„Å®„Éï„É¨„Éº„É†
                this.drawCardFrame(x, y, width, height, colors, rarity, isAnother, carData.element);

                // Â±ûÊÄß„Ç™„Éº„Éê„Éº„É¨„Ç§Ôºà„Ç´„Éº„ÉâÂÖ®‰Ωì„Å´ËñÑ„ÅèÔºâ
                ctx.fillStyle = element.bgColor;
                ctx.beginPath();
                ctx.roundRect(x + 2, y + 2, width - 4, height - 4, 13);
                ctx.fill();

                // ËªäÁîªÂÉè
                if (image) {
                    const imgPadding = 15;
                    const imgWidth = width - imgPadding * 2;
                    const imgHeight = height * 0.55;
                    ctx.save();
                    ctx.beginPath();
                    ctx.roundRect(x + imgPadding, y + imgPadding + 35, imgWidth, imgHeight, 8);
                    ctx.clip();
                    ctx.drawImage(image, x + imgPadding, y + imgPadding + 35, imgWidth, imgHeight);
                    ctx.restore();

                    // Ë£è„É¢„Éº„Éâ„Ç™„Éº„Éê„Éº„É¨„Ç§
                    if (isAnother) {
                        ctx.fillStyle = "rgba(138, 43, 226, 0.3)";
                        ctx.fillRect(x + imgPadding, y + imgPadding + 35, imgWidth, imgHeight);
                    }
                } else {
                    // „É≠„Éº„Éá„Ç£„É≥„Ç∞Ë°®Á§∫
                    ctx.fillStyle = "#333";
                    ctx.fillRect(x + 15, y + 50, width - 30, height * 0.55);
                    ctx.fillStyle = "#fff";
                    ctx.font = "16px Arial";
                    ctx.textAlign = "center";
                    ctx.fillText("Loading...", x + width / 2, y + height * 0.4);
                }

                // „É¨„Ç¢„É™„ÉÜ„Ç£„Éê„ÉÉ„Ç∏
                this.drawRarityBadge(x + 10, y + 10, rarity, isAnother);

                // Â±ûÊÄß„Éê„ÉÉ„Ç∏ÔºàÂè≥‰∏ä„Å´Ë°®Á§∫Ôºâ
                this.drawElementBadge(x + width - 50, y + 10, carData.element);

                // ËªäÂêç
                ctx.fillStyle = "#fff";
                ctx.font = "bold 16px Arial";
                ctx.textAlign = "center";
                ctx.shadowColor = "#000";
                ctx.shadowBlur = 4;
                ctx.fillText(carData.name, x + width / 2, y + height - 40);

                // APË°®Á§∫ÔºàÂ±ûÊÄßËâ≤„Çí„Ç¢„ÇØ„Çª„É≥„Éà„Å´Ôºâ
                ctx.font = "bold 24px Arial";
                ctx.fillStyle = isAnother ? "#ff00ff" : element.color;
                ctx.shadowColor = isAnother ? "#ff00ff" : element.color;
                ctx.shadowBlur = 10;
                const displayAp = isAnother ? Math.floor(carData.ap * 1.5) : carData.ap;
                ctx.fillText(`AP: ${displayAp}`, x + width / 2, y + height - 15);

                ctx.restore();

                // È´ò„É¨„Ç¢„É™„ÉÜ„Ç£„Ç®„Éï„Çß„ÇØ„Éà
                if (rarity === "SEC" || rarity === "GOD") {
                    this.drawGoldEffect(x, y, width, height);
                }
                if (rarity === "SR") {
                    this.drawRainbowEffect(x, y, width, height);
                }
                if (isAnother) {
                    this.drawAnotherAura(x, y, width, height);
                }

                // Â±ûÊÄß„Ç®„Éï„Çß„ÇØ„Éà
                this.drawElementEffect(x, y, width, height, carData.element);
            }

            drawElementBadge(x, y, elementKey) {
                const ctx = this.ctx;
                const element = ELEMENTS[elementKey];

                // „Éê„ÉÉ„Ç∏ËÉåÊôØ
                ctx.fillStyle = element.color;
                ctx.shadowColor = element.color;
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.roundRect(x, y, 40, 24, 5);
                ctx.fill();
                ctx.shadowBlur = 0;

                // „Ç¢„Ç§„Ç≥„É≥
                ctx.fillStyle = "#fff";
                ctx.font = "16px Arial";
                ctx.textAlign = "center";
                ctx.fillText(element.icon, x + 20, y + 18);
            }

            drawElementEffect(x, y, width, height, elementKey) {
                const ctx = this.ctx;
                const element = ELEMENTS[elementKey];

                // Â±ûÊÄß„Åî„Å®„ÅÆÂæÆÁ¥∞„Å™„Ç®„Éï„Çß„ÇØ„Éà
                ctx.save();
                ctx.globalAlpha = 0.3;

                switch (elementKey) {
                    case "fire":
                        // ÁÇé„ÅÆ„Éë„Éº„ÉÜ„Ç£„ÇØ„É´
                        for (let i = 0; i < 3; i++) {
                            const px = x + Math.random() * width;
                            const py = y + height - Math.random() * 30;
                            const size = Math.random() * 4 + 2;
                            ctx.fillStyle = `rgba(255, ${Math.floor(Math.random() * 100 + 100)}, 0, ${Math.random() * 0.5 + 0.3})`;
                            ctx.beginPath();
                            ctx.arc(px, py, size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                    case "wind":
                        // È¢®„ÅÆÁ∑ö
                        ctx.strokeStyle = element.color;
                        ctx.lineWidth = 1;
                        for (let i = 0; i < 2; i++) {
                            const startY = y + 50 + Math.random() * (height - 100);
                            ctx.beginPath();
                            ctx.moveTo(x, startY);
                            ctx.bezierCurveTo(
                                x + width * 0.3, startY - 10,
                                x + width * 0.7, startY + 10,
                                x + width, startY
                            );
                            ctx.stroke();
                        }
                        break;
                    case "thunder":
                        // Èõ∑„ÅÆÈñÉÂÖâ
                        if (Math.random() < 0.1) {
                            ctx.strokeStyle = element.color;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            const startX = x + Math.random() * width;
                            ctx.moveTo(startX, y);
                            let currentY = y;
                            while (currentY < y + height * 0.3) {
                                currentY += 10;
                                ctx.lineTo(startX + (Math.random() - 0.5) * 20, currentY);
                            }
                            ctx.stroke();
                        }
                        break;
                    case "earth":
                        // Âúü„ÅÆÁ≤íÂ≠ê
                        for (let i = 0; i < 4; i++) {
                            const px = x + Math.random() * width;
                            const py = y + height - 10 - Math.random() * 20;
                            ctx.fillStyle = element.color;
                            ctx.fillRect(px, py, 3, 3);
                        }
                        break;
                }
                ctx.restore();
            }

            drawCardFrame(x, y, width, height, colors, rarity, isAnother, elementKey = null) {
                const ctx = this.ctx;
                const gradient = ctx.createLinearGradient(x, y, x + width, y + height);
                const element = elementKey ? ELEMENTS[elementKey] : null;

                if (isAnother) {
                    gradient.addColorStop(0, "#4a0080");
                    gradient.addColorStop(0.5, "#800080");
                    gradient.addColorStop(1, "#4a0080");
                } else if (colors.rainbow) {
                    const hue = (this.time * 50) % 360;
                    gradient.addColorStop(0, `hsl(${hue}, 70%, 50%)`);
                    gradient.addColorStop(0.5, `hsl(${(hue + 120) % 360}, 70%, 50%)`);
                    gradient.addColorStop(1, `hsl(${(hue + 240) % 360}, 70%, 50%)`);
                } else if (colors.gold) {
                    gradient.addColorStop(0, "#ffd700");
                    gradient.addColorStop(0.3, "#ffec8b");
                    gradient.addColorStop(0.5, "#ffd700");
                    gradient.addColorStop(0.7, "#daa520");
                    gradient.addColorStop(1, "#ffd700");
                } else if (element) {
                    // Â±ûÊÄßËâ≤„Çí„Éï„É¨„Éº„É†„Å´ÂèçÊò†
                    gradient.addColorStop(0, element.color);
                    gradient.addColorStop(0.5, colors.primary);
                    gradient.addColorStop(1, element.color);
                } else {
                    gradient.addColorStop(0, colors.primary);
                    gradient.addColorStop(1, colors.secondary);
                }

                // Â§ñÊû†„Ç∞„É≠„ÉºÔºàÂ±ûÊÄßËâ≤„ÇÇÂèçÊò†Ôºâ
                ctx.shadowColor = isAnother ? "#ff00ff" : (element ? element.color : colors.glow);
                ctx.shadowBlur = 20;

                // „Ç´„Éº„ÉâÊú¨‰Ωì
                ctx.fillStyle = "#1a1a2e";
                ctx.beginPath();
                ctx.roundRect(x, y, width, height, 15);
                ctx.fill();

                // „Éï„É¨„Éº„É†
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 4;
                ctx.stroke();

                ctx.shadowBlur = 0;
            }

            drawRarityBadge(x, y, rarity, isAnother) {
                const ctx = this.ctx;
                const badgeColors = {
                    N: "#3498db",
                    R: "#c0c0c0",
                    SR: "#9b59b6",
                    SEC: "#ffd700",
                    GOD: "#ffd700"
                };

                const badgeWidth = rarity.length * 12 + 16;

                ctx.fillStyle = isAnother ? "#800080" : (badgeColors[rarity] || "#3498db");
                ctx.shadowColor = ctx.fillStyle;
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.roundRect(x, y, badgeWidth, 24, 5);
                ctx.fill();
                ctx.shadowBlur = 0;

                ctx.fillStyle = "#fff";
                ctx.font = "bold 14px Arial";
                ctx.textAlign = "center";
                const displayText = isAnother ? `${rarity}‚òÖ` : rarity;
                ctx.fillText(displayText, x + badgeWidth / 2, y + 17);
            }

            drawRainbowEffect(x, y, width, height) {
                const ctx = this.ctx;
                const hue = (this.time * 100) % 360;

                for (let i = 0; i < 4; i++) {
                    const angle = (this.time * 2 + i * Math.PI / 2) % (Math.PI * 2);
                    const px = x + width / 2 + Math.cos(angle) * (width / 2 + 15);
                    const py = y + height / 2 + Math.sin(angle) * (height / 2 + 15);

                    ctx.save();
                    ctx.fillStyle = `hsla(${(hue + i * 90) % 360}, 100%, 70%, 0.6)`;
                    ctx.shadowColor = `hsl(${(hue + i * 90) % 360}, 100%, 50%)`;
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(px, py, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            drawGoldEffect(x, y, width, height) {
                const ctx = this.ctx;

                // Á®≤Â¶ª„Ç®„Éï„Çß„ÇØ„Éà
                if (Math.random() < 0.1) {
                    ctx.save();
                    ctx.strokeStyle = "#ffd700";
                    ctx.shadowColor = "#ffd700";
                    ctx.shadowBlur = 20;
                    ctx.lineWidth = 2;
                    ctx.beginPath();

                    const startX = x + Math.random() * width;
                    const startY = y;
                    ctx.moveTo(startX, startY);

                    let currentY = startY;
                    while (currentY < y + height) {
                        currentY += Math.random() * 20 + 10;
                        const offsetX = (Math.random() - 0.5) * 40;
                        ctx.lineTo(startX + offsetX, Math.min(currentY, y + height));
                    }
                    ctx.stroke();
                    ctx.restore();
                }

                // Á≤íÂ≠ê„Ç®„Éï„Çß„ÇØ„Éà
                for (let i = 0; i < 2; i++) {
                    const px = x + Math.random() * width;
                    const py = y + height + 10;
                    if (Math.random() < 0.3) {
                        this.addParticles(px, py, "#ffd700", 1);
                    }
                }
            }

            drawAnotherAura(x, y, width, height) {
                const ctx = this.ctx;
                const pulse = Math.sin(this.time * 3) * 0.3 + 0.7;

                ctx.save();
                ctx.globalAlpha = 0.3 * pulse;

                const gradient = ctx.createRadialGradient(
                    x + width / 2, y + height / 2, 0,
                    x + width / 2, y + height / 2, width
                );
                gradient.addColorStop(0, "transparent");
                gradient.addColorStop(0.5, "rgba(138, 43, 226, 0.5)");
                gradient.addColorStop(1, "transparent");

                ctx.fillStyle = gradient;
                ctx.fillRect(x - 50, y - 50, width + 100, height + 100);
                ctx.restore();
            }
        }

        // ============================================
        // BattleManager „ÇØ„É©„Çπ
        // ============================================
        class BattleManager {
            constructor(imageLoader) {
                this.imageLoader = imageLoader;
                this.enemiesDefeated = 0;
                this.playerHp = 100;
                this.maxPlayerHp = 100;
                this.currentEnemy = null;
                this.enemyHp = 0;
                this.maxEnemyHp = 0;
                this.playerCard = null;
                this.playerImage = null;
                this.enemyImage = null;
                this.isPlayerAnother = false;
                this.battleState = "idle"; // idle, summoning, attacking, enemyAttack, victory, gameOver
                this.animationProgress = 0;
                this.damagePopups = [];
                this.screenShake = 0;
                this.attackPosition = { x: 0, y: 0 };
                this.message = "ÁîªÈù¢‰∏ãÈÉ®„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶„Ç¨„ÉÅ„É£„ÇíÂõû„Åù„ÅÜÔºÅ";
                this.lastElementBonus = null; // Â±ûÊÄßÁõ∏ÊÄß„Éú„Éº„Éä„ÇπË°®Á§∫Áî®
            }

            // Â±ûÊÄßÁõ∏ÊÄß„ÉÅ„Çß„ÉÉ„ÇØ: attacker„Åådefender„Å´ÊúâÂà©„Åã„Å©„ÅÜ„Åã
            checkElementAdvantage(attackerElement, defenderElement) {
                return ELEMENT_ADVANTAGE[attackerElement] === defenderElement;
            }

            // „ÉÄ„É°„Éº„Ç∏Ë®àÁÆóÔºàÂ±ûÊÄßÁõ∏ÊÄßËæº„ÅøÔºâ
            calculateDamage(baseDamage, attackerElement, defenderElement, isAnother = false) {
                let damage = baseDamage;
                let elementBonus = 1.0;

                // Ë£è„É¢„Éº„Éâ„Éú„Éº„Éä„Çπ
                if (isAnother) {
                    damage = Math.floor(damage * 1.5);
                }

                // Â±ûÊÄßÁõ∏ÊÄß„ÉÅ„Çß„ÉÉ„ÇØ
                if (this.checkElementAdvantage(attackerElement, defenderElement)) {
                    elementBonus = 1.5;
                    damage = Math.floor(damage * elementBonus);
                }

                return { damage, elementBonus };
            }

            getEnemyRarity() {
                const stage = Math.floor(this.enemiesDefeated / 3);
                if (stage >= 3) return "SEC";
                if (stage >= 2) return "SR";
                if (stage >= 1) return "R";
                return "N";
            }

            async spawnEnemy() {
                const targetRarity = this.getEnemyRarity();
                const candidates = CAR_DATA.filter(c => c.rarity === targetRarity);
                this.currentEnemy = candidates[Math.floor(Math.random() * candidates.length)];

                const hpMultiplier = 1 + this.enemiesDefeated * 0.2;
                this.maxEnemyHp = Math.floor(50 * hpMultiplier);
                this.enemyHp = this.maxEnemyHp;

                this.enemyImage = null;
                this.imageLoader.loadImage(this.currentEnemy.en, false).then(img => {
                    this.enemyImage = img;
                });
            }

            async summonCard() {
                if (this.battleState !== "idle") return;

                this.battleState = "summoning";
                this.animationProgress = 0;

                // „Ç¨„ÉÅ„É£„É≠„Ç∏„ÉÉ„ÇØ
                const roll = Math.random();
                let rarity;
                if (roll < 0.5) rarity = "N";
                else if (roll < 0.8) rarity = "R";
                else if (roll < 0.95) rarity = "SR";
                else rarity = "SEC";

                this.isPlayerAnother = Math.random() < 0.05;

                const candidates = CAR_DATA.filter(c => c.rarity === rarity);
                this.playerCard = candidates[Math.floor(Math.random() * candidates.length)];

                this.playerImage = null;
                this.imageLoader.loadImage(this.playerCard.en, this.isPlayerAnother).then(img => {
                    this.playerImage = img;
                });

                const rarityText = this.isPlayerAnother ? `${rarity}‚òÖ Ë£è„É¢„Éº„Éâ!!!` : rarity;
                const elemInfo = ELEMENTS[this.playerCard.element];
                this.message = `${elemInfo.icon} ${this.playerCard.name} (${rarityText}) „ÇíÂè¨ÂñöÔºÅ`;
            }

            attack(canvasWidth, canvasHeight) {
                if (this.battleState !== "summoning" || this.animationProgress < 1) return;

                this.battleState = "attacking";
                this.animationProgress = 0;
                this.attackPosition = {
                    x: canvasWidth / 2,
                    y: canvasHeight * 0.7
                };
            }

            update(deltaTime, canvasWidth, canvasHeight) {
                // „ÉÄ„É°„Éº„Ç∏„Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÊõ¥Êñ∞
                this.damagePopups = this.damagePopups.filter(p => p.life > 0);
                this.damagePopups.forEach(p => {
                    p.y -= 2;
                    p.life -= deltaTime;
                    p.alpha = Math.max(0, p.life);
                });

                // ÁîªÈù¢„Ç∑„Çß„Ç§„ÇØÊ∏õË°∞
                this.screenShake *= 0.9;
                if (this.screenShake < 0.5) this.screenShake = 0;

                switch (this.battleState) {
                    case "summoning":
                        this.animationProgress = Math.min(1, this.animationProgress + deltaTime * 2);
                        if (this.animationProgress >= 1 && this.playerImage) {
                            this.message = "„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶ÊîªÊíÉÔºÅ";
                        }
                        break;

                    case "attacking":
                        this.animationProgress += deltaTime * 3;

                        // ÊîªÊíÉ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                        const targetY = canvasHeight * 0.25;
                        this.attackPosition.y = canvasHeight * 0.7 - (canvasHeight * 0.7 - targetY) * Math.min(1, this.animationProgress);

                        if (this.animationProgress >= 1) {
                            // „ÉÄ„É°„Éº„Ç∏Ë®àÁÆóÔºàÂ±ûÊÄßÁõ∏ÊÄßËæº„ÅøÔºâ
                            const { damage, elementBonus } = this.calculateDamage(
                                this.playerCard.ap,
                                this.playerCard.element,
                                this.currentEnemy.element,
                                this.isPlayerAnother
                            );
                            this.lastElementBonus = elementBonus;

                            this.enemyHp = Math.max(0, this.enemyHp - damage);
                            this.screenShake = elementBonus > 1 ? 30 : 20;

                            // „ÉÄ„É°„Éº„Ç∏„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅÆËâ≤„ÇíÂ±ûÊÄß„Å´Âøú„Åò„Å¶Â§âÊõ¥
                            let popupColor = this.isPlayerAnother ? "#ff00ff" : "#ff4444";
                            if (elementBonus > 1) {
                                popupColor = ELEMENTS[this.playerCard.element].color;
                            }

                            this.damagePopups.push({
                                x: canvasWidth / 2,
                                y: canvasHeight * 0.25,
                                damage,
                                life: 1,
                                alpha: 1,
                                color: popupColor,
                                isElementBonus: elementBonus > 1
                            });

                            // „É°„ÉÉ„Çª„Éº„Ç∏„Å´Â±ûÊÄßÁõ∏ÊÄß„ÇíË°®Á§∫
                            const playerElem = ELEMENTS[this.playerCard.element];
                            const enemyElem = ELEMENTS[this.currentEnemy.element];
                            if (elementBonus > 1) {
                                this.message = `${playerElem.icon}${playerElem.name}Ôºû${enemyElem.name}${enemyElem.icon} ÂäπÊûúÊäúÁæ§ÔºÅ ${damage} „ÉÄ„É°„Éº„Ç∏ÔºÅ`;
                            } else {
                                this.message = `${damage} „ÉÄ„É°„Éº„Ç∏ÔºÅ`;
                            }

                            if (this.enemyHp <= 0) {
                                this.battleState = "victory";
                                this.animationProgress = 0;
                            } else {
                                this.battleState = "enemyAttack";
                                this.animationProgress = 0;
                            }
                        }
                        break;

                    case "enemyAttack":
                        this.animationProgress += deltaTime * 2;

                        if (this.animationProgress >= 1) {
                            const enemyDamage = Math.floor(this.currentEnemy.ap * 0.5);
                            this.playerHp = Math.max(0, this.playerHp - enemyDamage);
                            this.screenShake = 15;

                            this.damagePopups.push({
                                x: canvasWidth / 2,
                                y: canvasHeight * 0.75,
                                damage: enemyDamage,
                                life: 1,
                                alpha: 1,
                                color: "#ff0000"
                            });

                            if (this.playerHp <= 0) {
                                this.battleState = "gameOver";
                                this.message = "GAME OVER... „ÇØ„É™„ÉÉ„ÇØ„Åß„É™„Çπ„Çø„Éº„Éà";
                            } else {
                                this.battleState = "idle";
                                this.playerCard = null;
                                this.playerImage = null;
                                this.message = "„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶„Ç¨„ÉÅ„É£„ÇíÂõû„Åù„ÅÜÔºÅ";
                            }
                        }
                        break;

                    case "victory":
                        this.animationProgress += deltaTime;
                        if (this.animationProgress >= 1.5) {
                            this.enemiesDefeated++;
                            this.message = `ÂãùÂà©ÔºÅ ÊíÉÁ†¥Êï∞: ${this.enemiesDefeated} - Ê¨°„ÅÆÊïµ„ÅåÁèæ„Çå„ÅüÔºÅ`;
                            this.spawnEnemy();
                            this.battleState = "idle";
                            this.playerCard = null;
                            this.playerImage = null;
                        }
                        break;
                }
            }

            reset() {
                this.enemiesDefeated = 0;
                this.playerHp = this.maxPlayerHp;
                this.battleState = "idle";
                this.playerCard = null;
                this.playerImage = null;
                this.message = "ÁîªÈù¢‰∏ãÈÉ®„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶„Ç¨„ÉÅ„É£„ÇíÂõû„Åù„ÅÜÔºÅ";
                this.spawnEnemy();
            }
        }

        // ============================================
        // GameApp „ÇØ„É©„Çπ
        // ============================================
        class GameApp {
            constructor() {
                this.canvas = document.getElementById("gameCanvas");
                this.ctx = this.canvas.getContext("2d");

                this.resize();
                window.addEventListener("resize", () => this.resize());

                this.imageLoader = new ImageLoader();
                this.cardRenderer = new CardRenderer(this.ctx, this.imageLoader);
                this.battleManager = new BattleManager(this.imageLoader);

                this.lastTime = 0;
                this.backgroundStars = this.createStars();

                this.canvas.addEventListener("click", (e) => this.handleClick(e));

                this.battleManager.spawnEnemy();
                this.gameLoop(0);
            }

            resize() {
                this.canvas.width = Math.min(window.innerWidth, 800);
                this.canvas.height = Math.min(window.innerHeight, 900);
            }

            createStars() {
                const stars = [];
                for (let i = 0; i < 100; i++) {
                    stars.push({
                        x: Math.random(),
                        y: Math.random(),
                        size: Math.random() * 2 + 0.5,
                        speed: Math.random() * 0.001 + 0.0005
                    });
                }
                return stars;
            }

            handleClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const y = e.clientY - rect.top;

                if (this.battleManager.battleState === "gameOver") {
                    this.battleManager.reset();
                    return;
                }

                if (this.battleManager.battleState === "idle") {
                    this.battleManager.summonCard();
                } else if (this.battleManager.battleState === "summoning" && this.battleManager.animationProgress >= 1) {
                    this.battleManager.attack(this.canvas.width, this.canvas.height);
                }
            }

            gameLoop(timestamp) {
                const deltaTime = Math.min((timestamp - this.lastTime) / 1000, 0.1);
                this.lastTime = timestamp;

                this.update(deltaTime);
                this.render();

                requestAnimationFrame((t) => this.gameLoop(t));
            }

            update(deltaTime) {
                this.cardRenderer.update(deltaTime);
                this.battleManager.update(deltaTime, this.canvas.width, this.canvas.height);

                // ËÉåÊôØ„ÅÆÊòüÊõ¥Êñ∞
                this.backgroundStars.forEach(star => {
                    star.y += star.speed;
                    if (star.y > 1) star.y = 0;
                });
            }

            render() {
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;

                // ÁîªÈù¢„Ç∑„Çß„Ç§„ÇØÈÅ©Áî®
                ctx.save();
                if (this.battleManager.screenShake > 0) {
                    const shakeX = (Math.random() - 0.5) * this.battleManager.screenShake;
                    const shakeY = (Math.random() - 0.5) * this.battleManager.screenShake;
                    ctx.translate(shakeX, shakeY);
                }

                // ËÉåÊôØ
                this.drawBackground(w, h);

                // UI„Çª„Éë„É¨„Éº„Çø
                ctx.strokeStyle = "rgba(255, 255, 255, 0.2)";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, h * 0.5);
                ctx.lineTo(w, h * 0.5);
                ctx.stroke();

                // Êïµ„Ç®„É™„Ç¢
                this.drawEnemyArea(w, h);

                // „Éó„É¨„Ç§„É§„Éº„Ç®„É™„Ç¢
                this.drawPlayerArea(w, h);

                // „ÉÄ„É°„Éº„Ç∏„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó
                this.drawDamagePopups();

                // „É°„ÉÉ„Çª„Éº„Ç∏
                this.drawMessage(w, h);

                // „Éë„Éº„ÉÜ„Ç£„ÇØ„É´
                this.cardRenderer.drawParticles();

                ctx.restore();
            }

            drawBackground(w, h) {
                const ctx = this.ctx;

                // „Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥ËÉåÊôØ
                const bgGradient = ctx.createLinearGradient(0, 0, 0, h);
                bgGradient.addColorStop(0, "#0a0a1a");
                bgGradient.addColorStop(0.5, "#1a1a3a");
                bgGradient.addColorStop(1, "#0a0a1a");
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, 0, w, h);

                // Êòü
                ctx.fillStyle = "#fff";
                this.backgroundStars.forEach(star => {
                    ctx.globalAlpha = 0.3 + Math.random() * 0.4;
                    ctx.beginPath();
                    ctx.arc(star.x * w, star.y * h, star.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
            }

            drawEnemyArea(w, h) {
                const ctx = this.ctx;
                const bm = this.battleManager;

                // „É©„Éô„É´
                ctx.fillStyle = "#ff4444";
                ctx.font = "bold 24px Arial";
                ctx.textAlign = "left";
                ctx.shadowColor = "#ff0000";
                ctx.shadowBlur = 10;
                ctx.fillText("„ÄêENEMY„Äë", 20, 40);
                ctx.shadowBlur = 0;

                // ÊíÉÁ†¥Êï∞Ë°®Á§∫
                ctx.fillStyle = "#ffcc00";
                ctx.font = "18px Arial";
                ctx.textAlign = "right";
                ctx.fillText(`ÊíÉÁ†¥: ${bm.enemiesDefeated}`, w - 20, 40);

                if (bm.currentEnemy) {
                    // ÊïµHP„Éê„Éº
                    this.drawHPBar(w / 2 - 150, 55, 300, 25, bm.enemyHp, bm.maxEnemyHp, "#ff4444", "#aa0000");

                    // ÊïµËªäÁ®ÆÂêç„Å®Â±ûÊÄß
                    const enemyElem = ELEMENTS[bm.currentEnemy.element];
                    ctx.fillStyle = "#fff";
                    ctx.font = "bold 20px Arial";
                    ctx.textAlign = "center";
                    ctx.fillText(`${enemyElem.icon} ${bm.currentEnemy.name} [${bm.currentEnemy.rarity}]`, w / 2, 105);

                    // Êïµ„Ç´„Éº„Éâ
                    const cardWidth = 280;
                    const cardHeight = 350;
                    const cardX = w / 2 - cardWidth / 2;
                    const cardY = 115;

                    // ÊïµÊîªÊíÉ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                    let enemyOffset = 0;
                    if (bm.battleState === "enemyAttack") {
                        enemyOffset = Math.sin(bm.animationProgress * Math.PI) * 50;
                    }

                    this.cardRenderer.drawCard(
                        cardX, cardY + enemyOffset,
                        cardWidth, cardHeight,
                        bm.currentEnemy, bm.enemyImage, false, 1
                    );

                    // ÂãùÂà©„Ç®„Éï„Çß„ÇØ„Éà
                    if (bm.battleState === "victory") {
                        ctx.save();
                        ctx.fillStyle = "rgba(255, 215, 0, 0.3)";
                        ctx.fillRect(0, 0, w, h * 0.5);

                        ctx.fillStyle = "#ffd700";
                        ctx.font = "bold 48px Arial";
                        ctx.textAlign = "center";
                        ctx.shadowColor = "#ffd700";
                        ctx.shadowBlur = 20;
                        ctx.fillText("VICTORY!", w / 2, h * 0.3);
                        ctx.restore();
                    }
                }
            }

            drawPlayerArea(w, h) {
                const ctx = this.ctx;
                const bm = this.battleManager;

                // „É©„Éô„É´
                ctx.fillStyle = "#44aaff";
                ctx.font = "bold 24px Arial";
                ctx.textAlign = "left";
                ctx.shadowColor = "#0088ff";
                ctx.shadowBlur = 10;
                ctx.fillText("„ÄêPLAYER„Äë", 20, h * 0.5 + 35);
                ctx.shadowBlur = 0;

                // „Éó„É¨„Ç§„É§„ÉºHP„Éê„Éº
                this.drawHPBar(w / 2 - 150, h * 0.5 + 45, 300, 25, bm.playerHp, bm.maxPlayerHp, "#44ff44", "#00aa00");

                // Âè¨Âñö„Ç®„É™„Ç¢
                if (bm.playerCard && bm.playerImage) {
                    const cardWidth = 240;
                    const cardHeight = 300;
                    let cardX = w / 2 - cardWidth / 2;
                    let cardY = h * 0.5 + 85;

                    if (bm.battleState === "attacking") {
                        cardX = bm.attackPosition.x - cardWidth / 2;
                        cardY = bm.attackPosition.y - cardHeight / 2;
                    }

                    this.cardRenderer.drawCard(
                        cardX, cardY,
                        cardWidth, cardHeight,
                        bm.playerCard, bm.playerImage,
                        bm.isPlayerAnother,
                        bm.animationProgress
                    );
                } else if (bm.battleState === "idle") {
                    // „Ç¨„ÉÅ„É£Ë™òÂ∞é
                    ctx.save();
                    const pulse = Math.sin(Date.now() / 300) * 0.2 + 0.8;
                    ctx.globalAlpha = pulse;

                    ctx.strokeStyle = "#44aaff";
                    ctx.lineWidth = 3;
                    ctx.setLineDash([10, 10]);
                    ctx.strokeRect(w / 2 - 120, h * 0.65, 240, 200);
                    ctx.setLineDash([]);

                    ctx.fillStyle = "#44aaff";
                    ctx.font = "24px Arial";
                    ctx.textAlign = "center";
                    ctx.fillText("TAP TO SUMMON", w / 2, h * 0.75);
                    ctx.restore();
                }

                // „Ç≤„Éº„É†„Ç™„Éº„Éê„Éº
                if (bm.battleState === "gameOver") {
                    ctx.save();
                    ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                    ctx.fillRect(0, 0, w, h);

                    ctx.fillStyle = "#ff0000";
                    ctx.font = "bold 56px Arial";
                    ctx.textAlign = "center";
                    ctx.shadowColor = "#ff0000";
                    ctx.shadowBlur = 20;
                    ctx.fillText("GAME OVER", w / 2, h / 2 - 30);

                    ctx.fillStyle = "#fff";
                    ctx.font = "24px Arial";
                    ctx.shadowBlur = 0;
                    ctx.fillText(`ÊíÉÁ†¥Êï∞: ${bm.enemiesDefeated}`, w / 2, h / 2 + 20);
                    ctx.fillText("„ÇØ„É™„ÉÉ„ÇØ„Åß„É™„Çπ„Çø„Éº„Éà", w / 2, h / 2 + 60);
                    ctx.restore();
                }
            }

            drawHPBar(x, y, width, height, current, max, color, darkColor) {
                const ctx = this.ctx;
                const ratio = Math.max(0, current / max);

                // ËÉåÊôØ
                ctx.fillStyle = "#333";
                ctx.beginPath();
                ctx.roundRect(x, y, width, height, 5);
                ctx.fill();

                // HP
                if (ratio > 0) {
                    const gradient = ctx.createLinearGradient(x, y, x, y + height);
                    gradient.addColorStop(0, color);
                    gradient.addColorStop(1, darkColor);
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.roundRect(x + 2, y + 2, (width - 4) * ratio, height - 4, 3);
                    ctx.fill();
                }

                // „ÉÜ„Ç≠„Çπ„Éà
                ctx.fillStyle = "#fff";
                ctx.font = "bold 14px Arial";
                ctx.textAlign = "center";
                ctx.fillText(`${current} / ${max}`, x + width / 2, y + height - 7);
            }

            drawDamagePopups() {
                const ctx = this.ctx;

                this.battleManager.damagePopups.forEach(popup => {
                    ctx.save();
                    ctx.globalAlpha = popup.alpha;
                    ctx.fillStyle = popup.color;
                    ctx.font = "bold 48px Arial";
                    ctx.textAlign = "center";
                    ctx.shadowColor = popup.color;
                    ctx.shadowBlur = 15;
                    ctx.fillText(`-${popup.damage}`, popup.x, popup.y);
                    ctx.restore();
                });
            }

            drawMessage(w, h) {
                const ctx = this.ctx;

                ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                ctx.beginPath();
                ctx.roundRect(w / 2 - 200, h - 50, 400, 40, 10);
                ctx.fill();

                ctx.fillStyle = "#fff";
                ctx.font = "18px Arial";
                ctx.textAlign = "center";
                ctx.fillText(this.battleManager.message, w / 2, h - 25);
            }
        }

        // ============================================
        // „Ç≤„Éº„É†ÈñãÂßã
        // ============================================
        window.addEventListener("load", () => {
            new GameApp();
        });
    </script>
</body>

</html>