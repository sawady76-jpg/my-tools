<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>OCRミニ（PDF/画像 → テキスト）</title>
<style>
  body{margin:0;background:#0b1020;color:#e8eefa;font-family:system-ui,-apple-system,Segoe UI,Roboto,Meiryo,sans-serif}
  header{padding:16px 18px;border-bottom:1px solid #223}
  .wrap{max-width:900px;margin:18px auto;padding:0 14px}
  .panel{background:#121a2f;border:1px solid #1f2740;border-radius:14px;padding:14px;margin-bottom:14px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  button{background:#4f8cff;border:1px solid #3a6ee8;color:#fff;border-radius:10px;padding:8px 12px;cursor:pointer}
  textarea{width:100%;min-height:220px;background:#0f162a;color:#e8eefa;border:1px solid #283253;border-radius:12px;padding:10px;white-space:pre-wrap}
  label{font-size:12px;color:#93a1bd}
</style>

<!-- ★ unpkg ではなく jsDelivr を使用（ブロック回避） -->
<script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@4.6.82/build/pdf.min.js" crossorigin="anonymous"></script>
<script>
  pdfjsLib.GlobalWorkerOptions.workerSrc =
    'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.6.82/build/pdf.worker.min.js';
</script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/tesseract.min.js" crossorigin="anonymous"></script>
</head>

<body>
<header><h1>OCRミニ（PDF/画像 → テキスト）</h1></header>
<div class="wrap">
  <section class="panel">
    <div class="row">
      <input id="file" type="file" accept="application/pdf,image/png,image/jpeg" multiple>
      <button id="run">実行</button>
      <label><input id="forceOcr" type="checkbox"> 常にOCR（PDF埋込テキスト無視）</label>
      <span id="status" style="font:12px ui-monospace,Menlo,Consolas,monospace"></span>
    </div>
    <div class="row" style="font:12px ui-monospace,Menlo,Consolas,monospace;color:#93a1bd;margin-top:6px">
      Live Server など http://localhost で開いてください（file:// は非推奨）
    </div>
  </section>

  <section class="panel">
    <div>出力</div>
    <textarea id="out" placeholder="ここに結果が出ます"></textarea>
  </section>
</div>

<script>
const el = {
  file: document.getElementById('file'),
  run: document.getElementById('run'),
  force: document.getElementById('forceOcr'),
  status: document.getElementById('status'),
  out: document.getElementById('out'),
};

window.addEventListener('error', e=>{
  el.status.textContent = 'エラー: ' + e.message;
});
window.addEventListener('unhandledrejection', e=>{
  const r=e.reason; el.status.textContent='エラー: ' + (r&&r.message?r.message:r);
});

el.run.addEventListener('click', async ()=>{
  if(!el.file.files.length){ el.status.textContent='ファイルを選択'; return; }
  if(!window.pdfjsLib){ el.status.textContent='エラー: PDF.jsの読み込みに失敗'; return; }
  if(!window.Tesseract){ el.status.textContent='エラー: Tesseract.jsの読み込みに失敗'; return; }

  el.status.textContent='初期化中…';

  // ★ ここを“文字列”にする（関数を渡すと DataCloneError）
  const worker = await Tesseract.createWorker({
    workerPath: 'https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/worker.min.js',
    corePath:   'https://cdn.jsdelivr.net/npm/tesseract.js-core@5.1.0/tesseract-core.wasm.js',
    // ベースURL（末尾に /{lang}.traineddata.gz が付与される）
    langPath:   'https://tessdata.projectnaptha.com/5.0.0_fast',
    logger: m => { if(m.status==='recognizing text') el.status.textContent=`文字認識中… ${Math.round(m.progress*100)}%`; }
  });

  try{ await worker.loadLanguage('jpn+eng'); await worker.initialize('jpn+eng'); }
  catch{ await worker.loadLanguage('eng'); await worker.initialize('eng'); }

  const parts=[];
  for(const f of el.file.files){
    el.status.textContent=`処理中… (${f.name})`;
    if((f.type||'').includes('pdf') || /\.pdf$/i.test(f.name)){
      const buf=await f.arrayBuffer();
      const pdf=await pdfjsLib.getDocument({data:buf}).promise;
      for(let i=1;i<=pdf.numPages;i++){
        const page=await pdf.getPage(i);
        let text='';
        if(!el.force.checked){
          try{ const tc=await page.getTextContent(); text=(tc.items||[]).map(it=>it.str).join('\n'); }catch{}
        }
        if(el.force.checked || !text.trim()){
          const vp=page.getViewport({scale:2});
          const c=document.createElement('canvas'); const cx=c.getContext('2d');
          c.width=vp.width; c.height=vp.height;
          await page.render({canvasContext:cx,viewport:vp}).promise;
          const {data:{text:t}}=await worker.recognize(c.toDataURL('image/png'));
          text=t||'';
        }
        parts.push(`--- ${f.name} p.${i} ---\n${text}\n`);
      }
    }else{
      const url=URL.createObjectURL(f);
      const {data:{text}}=await worker.recognize(url); URL.revokeObjectURL(url);
      parts.push(`--- ${f.name} ---\n${text||''}\n`);
    }
  }
  await worker.terminate();
  el.out.value=parts.join('\n'); el.status.textContent='完了';
});
</script>
</body>
</html>
